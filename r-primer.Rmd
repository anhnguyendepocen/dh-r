```{r include=FALSE, cache=FALSE}
set.seed(4356)
options(digits = 3)

knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  cache = TRUE,
  out.width = "100%",
  fig.align = "left",
  fig.width = 8,
  fig.asp = 0.618,  # 1 / phi
  fig.show = "hold"
)

options(dplyr.print_min = 6, dplyr.print_max = 6)
```
# An R primer {#primer}

What follows is a highly condensed guide to the basic features of the R programming language and some of its most useful general purpose packages. Use this primer as a quick introduction to the language, or as a reference when reading the rest of the book. You should also read at a minimum the chapters on "[Data Structures](http://adv-r.had.co.nz/Data-structures.html)" and "[Subsetting](http://adv-r.had.co.nz/Subsetting.html)" from *[Advanced R](http://adv-r.had.co.nz/)*, since understanding those concepts are crucial to working effectively in R.^[@wickham_advanced_2014, chs. 2--3.]

## Values

A **value** is the most basic piece of data. There are several kinds of values.

**Doubles** are positive or negative numbers that can have a decimal point. **Integers** are positive or negative whole numbers. Even if a value does not have a decimal point, it is a double unless it is suffixed with `L`. 

```{r}
10.42
-8.67
10L
-8L
```

Text is stored in **character** vectors (usually called strings in other programming langauges). Characters are marked by surrounding single or double quotation marks.

```{r}
"Everything is awesome"
"1" # not the same as 1
identical(1, "1")
```

**Logical** values, or booleans, can be either true or false.

```{r}
TRUE
FALSE
```

**Factors** are a special kind of text value, where the values must be part of a predefined set of options. Factors are usually used for categorical data. 

```{r}
factor(c("correct", "correct", "incorrect"), levels = c("correct", "incorrect"))
```

Each of these kinds of values has a corresponding missing value, `NA`. These are used for missing or unrecorded data.

```{r}
NA
NA_character_
NA_integer_
NA_real_
```

## Variables and assignment

Values can be stored in **variables**. A value is placed into a variable using the assignment operator, `<-`.

```{r}
x <- 1
x
y <- -3.14
y
result <- "The results are positive"
result
```

## Comparison

Values can be compared to one another. The result is always a vector of `TRUE` and `FALSE` values indicating whether the condition was met or not. 

```{r}
x <- 1:6 # a vector of numbers 1 to 6
x > 3
x >= 3
x < 3
x == 3
x != 3
```

Comparison also works with character vectors.

```{r}
"Is this the same?" == "as this?"
"Is this the same?" == "Is this the same?"
```

Notice that equality is tested with the `==` operater, not with `=`.

Often it is helpful to test whether elements of one vector are contained in another vector with the `%in%` function. Notice that the resulting vector is the same length as the vector on the left-hand side.

```{r}
c(1, 4, 2, 8, 0, 10) %in% c(1, 2, 3)

# Are these states a part of New England?
states <- c("VA", "CT", "MA", "SD", "GA", "AL", "ND", "SD", "VT") 
new_england <-  c("MA", "ME", "CT", "RI", "NH", "VT")
states %in% new_england
```

## Using functions

R is a functional programming language, so knowing how to apply functions to problems, and to write them yourself, is essential to doing your work.

**Functions** can be called on many different kinds of R vectors and objects. A function takes an input and produces an output. In this case we will use `sum()` to add up a vector of numbers.

```{r}
x <- c(1, 5, 2, 4, 2, 5)
sum(x)
```

Notice that calls to functions are always followed by parentheses, containing the function **arguments**. In the example above, `x` was the only argument to the function; it was the means by which we passed data into the function. Functions can often take many arguments that specify options to function. For instance, if we have a vector of numbers that contains an missing value (`NA`), then the function `sum()` will return `NA`, because `NA` has no value. But by using the `na.rm` argument to `sum()`, we can instruct it to ignore `NA` values.

```{r}
y <- c(1, NA, 2, 4, 2, 5)
sum(y)
sum(y, na.rm = TRUE)
```

R has many built-in functions. For instance, the `sort()` function can sort many different kinds of values.

```{r}
x
sort(x)
sort(x, decreasing = TRUE)

states
sort(states)
sort(states, decreasing = TRUE)
```

It is important to note that most functions you use to work with data are **pure functions**. The results of pure functions depend only on their inputs: the same input will always produce the same output. And in general, R functions do not modify their inputs directly, but instead return a copy they modify their inputs. Notice that in this example the original `states` vector remains unsorted, even after it has been passed through the `sort()` function, and a new copy of the data, now sorted, is stored in the variable `states_sorted`. This makes it easier to reason about what a function will do.

```{r}
states
states_sorted <- sort(states)

states
states_sorted
```
