# An R primer {#primer}

What follows is a highly condensed guide to the basic features of the R programming language and some of its most useful general purpose packages. Use this primer as a quick introduction to the language, or as a reference when reading the rest of the book. You should also read at a minimum the chapters on "[Data Structures](http://adv-r.had.co.nz/Data-structures.html)" and "[Subsetting](http://adv-r.had.co.nz/Subsetting.html)" from *[Advanced R](http://adv-r.had.co.nz/)*, since understanding those concepts are crucial to working effectively in R.^[@wickham_advanced_2014, chs. 2--3.]

## Values

A **value** is the most basic piece of data. There are several kinds of values.

**Doubles** are positive or negative numbers that can have a decimal point. **Integers** are positive or negative whole numbers. Even if a value does not have a decimal point, it is a double unless it is suffixed with `L`. 

```{r}
10.42
-8.67
10L
-8L
```

Text is stored in **character** vectors (usually called strings in other programming langauges). Characters are marked by surrounding single or double quotation marks.

```{r}
"Everything is awesome"
"1" # not the same as 1
identical(1, "1")
```

**Logical** values, or booleans, can be either true or false.

```{r}
TRUE
FALSE
```

**Factors** are a special kind of text value, where the values must be part of a predefined set of options. Factors are usually used for categorical data. 

```{r}
factor(c("correct", "correct", "incorrect"), levels = c("correct", "incorrect"))
```

Each of these kinds of values has a corresponding missing value, `NA`. These are used for missing or unrecorded data.

```{r}
NA
NA_character_
NA_integer_
NA_real_
```

## Variables and assignment

Values can be stored in **variables**. A value is placed into a variable using the assignment operator, `<-`.

```{r}
x <- 1
x
y <- -3.14
y
result <- "The results are positive"
result
```

## Comparison

Values can be compared to one another. The result is always a vector of `TRUE` and `FALSE` values indicating whether the condition was met or not. 

```{r}
x <- 1:6 # a vector of numbers 1 to 6
x > 3
x >= 3
x < 3
x == 3
x != 3
```

Comparison also works with character vectors.

```{r}
"Is this the same?" == "as this?"
"Is this the same?" == "Is this the same?"
```

Notice that equality is tested with the `==` operater, not with `=`.

Often it is helpful to test whether elements of one vector are contained in another vector with the `%in%` function. Notice that the resulting vector is the same length as the vector on the left-hand side.

```{r}
c(1, 4, 2, 8, 0, 10) %in% c(1, 2, 3)

# Are these states a part of New England?
states <- c("VA", "CT", "MA", "SD", "GA", "AL", "ND", "SD", "VT") 
new_england <-  c("MA", "ME", "CT", "RI", "NH", "VT")
states %in% new_england
```

## Using functions

R is a functional programming language, so knowing how to apply functions to problems, and to write them yourself, is essential to doing your work. Functions are the verbs of R programming.

**Functions** can be called on many different kinds of R vectors and objects. A function takes an input and produces an output. In this case we will use `sum()` to add up a vector of numbers.

```{r}
x <- c(1, 5, 2, 4, 2, 5)
sum(x)
```

Notice that calls to functions are always followed by parentheses, containing the function **arguments**. In the example above, `x` was the only argument to the function; it was the means by which we passed data into the function. Functions can often take many arguments that specify options to function. For instance, if we have a vector of numbers that contains an missing value (`NA`), then the function `sum()` will return `NA`, because `NA` has no value. But by using the `na.rm` argument to `sum()`, we can instruct it to ignore `NA` values.

```{r}
y <- c(1, NA, 2, 4, 2, 5)
sum(y)
sum(y, na.rm = TRUE)
```

R has many built-in functions. For instance, the `sort()` function can sort many different kinds of values.

```{r}
x
sort(x)
sort(x, decreasing = TRUE)

states
sort(states)
sort(states, decreasing = TRUE)
```

It is important to note that most functions you use to work with data are **pure functions**. The results of pure functions depend only on their inputs: the same input will always produce the same output. And in general, R functions do not modify their inputs directly, but instead return a copy they modify their inputs. Notice that in this example the original `states` vector remains unsorted, even after it has been passed through the `sort()` function, and a new copy of the data, now sorted, is stored in the variable `states_sorted`. This makes it easier to reason about what a function will do.

```{r}
states
states_sorted <- sort(states)

states
states_sorted
```

## Data structures and subsetting

If functions are the verbs of R programming, data are the nouns. And data can be stored in many different kinds of **data structures**, including vectors, lists, data frames, and matrices. These kinds of data structures share a set of operators for subsetting them, that is, for pulling out pieces of the data.

### Vectors

The most basic data structure is a vector. Consider this vector of 10 names.

```{r}
people <- c("Adam", "Betsy", "Charles", "Dana", "Edward", "Felicity", "George",
            "Hannah", "Ian", "Julia")
```

In R, elements of a vector are numbered, starting from `1` to the length of the vector. (Most programming languages have a 0-based indexing.) We can get individual elements of the vector using a numeric vector and the `[` subsetting operator. For example, we can get the fifth element, or the first, eighth, tenth, and sixth elements together.

```{r}
people[5]
people[c(1, 8, 10, 6)]
```

We can also subset a vector by using a logical vector. When we use a logical vector, we get back the elements that correspond to the `TRUE` values. It is usually a good idea to use a logical vector which has same length as the original vector. In this example, we use a function to test whether the names in our `people` vector have a lowercase `e` in them. Then we use that logical vector and the `[` subset operator to return only the names that have that letter in them.

```{r}
library(stringr)
# The result of this function call is a logical vector
str_detect(people, "e") 

people[str_detect(people, "e")]
```

It is possible for a vector to have names, which we can also use for subsetting. Suppose we have a set of numbers from `1` to `10` that correspond to a rank for each person. At first our vector does not have any names.

```{r}
rank <- c(9, 8, 4, 10, 7, 3, 2, 5, 1, 6)
names(rank)
```

But we can use our `people` vector to give it names.

```{r}
names(rank) <- people
```

Now we can get the fifth rank and see the corresponding name.

```{r}
rank[5]
```

We can use a character vector to subset `rank` to using those names.

```{r}
rank[c("Adam", "Hannah")]
```

And we can sort `rank` and see that the names are also sorted, or get only the elements of rank which are above a certain value (another example of logical subsetting).

```{r}
sort(rank)
rank[rank <= 3]
```
